from __future__ import annotations

import json
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Dict

import numpy as np


@dataclass
class CameraCalib:
    name: str
    K: np.ndarray          # (3,3)
    dist: np.ndarray       # (N,)  (k1,k2,p1,p2,k3...) or empty
    R_wc: np.ndarray       # (3,3) world->camera
    t_wc: np.ndarray       # (3,)  world->camera
    image_size: tuple[int, int]  # (W,H)


@dataclass
class RigCalib:
    fps: float
    left: CameraCalib
    right: CameraCalib
    left_offset_frames: int = 0


def _arr(x: Any, shape: tuple[int, ...]) -> np.ndarray:
    a = np.array(x, dtype=np.float64)
    if a.shape != shape:
        raise ValueError(f"Expected shape {shape}, got {a.shape}")
    return a


def load_rig_json(path: str | Path) -> RigCalib:
    path = Path(path)
    obj: Dict[str, Any] = json.loads(path.read_text())

    # ---- New-format rig JSON (explicit cameras dict) ----
    if "cameras" in obj:
        fps = float(obj.get("fps", 120.0))
        sync = obj.get("frame_sync", {}) or {}
        left_offset_frames = int(sync.get("left_offset_frames", 0))

        cams = obj["cameras"]

        def load_cam(side: str) -> CameraCalib:
            c = cams[side]
            return CameraCalib(
                name=str(c.get("name", side)),
                K=_arr(c["K"], (3, 3)),
                dist=np.array(c.get("dist", []), dtype=np.float64),
                R_wc=_arr(c["R_wc"], (3, 3)),
                t_wc=np.array(c["t_wc"], dtype=np.float64).reshape(3),
                image_size=tuple(c["image_size"]),
            )

        return RigCalib(
            fps=fps,
            left=load_cam("left"),
            right=load_cam("right"),
            left_offset_frames=left_offset_frames,
        )

    # ---- Backwards-compatible loader for stereo_offline_calibration_*.json ----
    # Generated by apps/calibration_testing/stereo_cam_calibrator_offline.py
    # Schema:
    #   image_size: [W, H]
    #   K0, D0, K1, D1: intrinsics/distortion for cam0/cam1
    #   R, T: extrinsics from cam0 -> cam1 as returned by cv2.stereoCalibrate
    # We treat cam0 as the "left" camera and define world == cam0 frame:
    #   left:  R_wc = I,        t_wc = 0
    #   right: R_wc = R,        t_wc = T
    if "K0" in obj and "K1" in obj and "R" in obj and "T" in obj:
        W, H = obj["image_size"]

        def _flatten_D(D_any: Any) -> np.ndarray:
            d = np.array(D_any, dtype=np.float64).reshape(-1)
            return d

        K0 = _arr(obj["K0"], (3, 3))
        D0 = _flatten_D(obj.get("D0", []))
        K1 = _arr(obj["K1"], (3, 3))
        D1 = _flatten_D(obj.get("D1", []))
        R = _arr(obj["R"], (3, 3))
        T = np.array(obj["T"], dtype=np.float64).reshape(3)

        left = CameraCalib(
            name="left",
            K=K0,
            dist=D0,
            R_wc=np.eye(3, dtype=np.float64),
            t_wc=np.zeros(3, dtype=np.float64),
            image_size=(int(W), int(H)),
        )
        right = CameraCalib(
            name="right",
            K=K1,
            dist=D1,
            R_wc=R,
            t_wc=T,
            image_size=(int(W), int(H)),
        )

        # No FPS info is stored in these files; leave default and offset=0.
        return RigCalib(
            fps=float(obj.get("fps", 120.0)),
            left=left,
            right=right,
            left_offset_frames=0,
        )

    raise ValueError(f"Unrecognized rig calibration JSON format in: {path}")


def projection_matrix(cam: CameraCalib) -> np.ndarray:
    """
    P = K [R|t] where X_cam = R_wc X_world + t_wc
    """
    Rt = np.hstack([cam.R_wc, cam.t_wc.reshape(3, 1)])
    return cam.K @ Rt


